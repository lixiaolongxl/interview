# 数据类型
***
#### typeof 和 instanceof 的区别
- typeof 返回的对应的数据类型 typeof null 返回 object 
    当检查的数据内部有call方法的时候会返回一个function 否则返回的就是一个object
    少了一个null 多一个function
    ```js
        typeof new String('lixiaong')  => object
    ```
- instanceof 返回的是布尔类似的数据  检测某一个数据是另一个实例化后出来的；
    1. 检测时会顺着原型链向上找，找到就为true
    ```js
        [] instanceof Array   => true
        [] instanceof Object   => true
        <!-- 可以用来判断 Object Array 的区别 -->
        console.log(Object.prototype.toString.call('1')); //[object String]
        console.log(Object.prototype.toString.call([])); //[object Array]
    ```
- typeof 检测基础数据类型 instanceof 通常检测引用数据类型
#### 数据存储类型堆和栈
- 栈：**计算机为原始数据类型开辟的一块内存空间**
- 堆：**计算机为引用数据类型开辟的一块内存空间**
    堆依赖栈，一个引用类型的数据定义，首先在栈上定义一个地址，然后指向堆
#### 常见的数据类型转换有哪些方式
1. 特殊类型的的隐士转换  NaN O null undefined '' => true false 内部用Boolean() 函数转换了
2. == 会做隐试类型转换
#### js 舍入误差
+ 原因是由于小数重二进制转十进制是舍弃一部分数据导致的
+ 解决方案
    1. 用toFixed()
    2. 小数转整数
#### JS 中常见的内在对象有哪些
+ 三种包装对象 String Number Boolear
    1. 通常定义一个数据比如 var a = '1111' 内部先做了 new String('1111')  a 才有了string 的一一些常见的属性和方法
+ 内置对象 Array Date Function Object Math...
#### js 装箱和拆箱
+ 装箱：把基础数据类型转化为对应的引用数据类型
    ```js
    var number = new Number(1)
    ```
+ 拆箱：吧引用数据类型转化为对应的值类型对象
    

   ```js
    new Number(1).valueOf()  # 转化为值类型
   ```
#### js求[ ]+[ ] 的值
```js
    // 拆箱内部调用toPrimitive方法
    // 1. 先判断传入的值是否是原始值，是直接返回
    // 2. 不是就调用valueOf()，判断结果是否是原始值，是直接返回
    // 3. 不是就调用toString 返回string    
    console.log([]+[]) // 返回 ""

    + [] =>0
    
    {} + [] =>0
    
    [] + {} =>'[object Object]'
    
    [] + [] =>''
    
    {} + {} =>'[object Object][object Object]'
    
```



